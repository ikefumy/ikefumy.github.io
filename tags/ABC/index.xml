<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ABC on ikefumy's memo</title><link>https://ikefumy.github.io/tags/ABC/</link><description>Recent content in ABC on ikefumy's memo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ikefumy.github.io/tags/ABC/index.xml" rel="self" type="application/rss+xml"/><item><title>ABC290 参加記</title><link>https://ikefumy.github.io/docs/1676803816/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1676803816/</guid><description>結果
US配列で参加する二回目のコンテスト。まだタイピングがおぼつかなくて、=を入力したかったのに_を入力してしまったり、*の位置が分からなくなったりする。 久々の三桁順位で萎えた。
コンテストのURL
振り返り
A
やるだけ。指の体操
B
K-- &amp;gt; 0で判定すると楽な気がする。
C
最初は$A$をソートしたりuniqueしたりしようとしてたけど、set使った方が楽なのでそっちに変更して書いた。
D
予選仕様なだけあってちょっとむずい気がしたけどqual Aよりはマシな難易度してた気がする。qual AのDは解法思い浮かぶまで時間かかったけどこれはすぐ浮かんだので。問題文を理解するのにちょっと時間がかかったけど用は$D$ずつ飛び飛びで塗って、同じ所に戻ってきたらずれるだけか～とわかった。マス$0$を出発した後、次にマス$0$に到達する時を$x$回目だとすると、$x \times D \equiv 0 \pmod N$ が成り立つ。よって $x \times D = \operatorname{lcm}(D, N)$ となり、変形すると $x = N / \gcd(D, N)$ となる。よって答えは \(
((K - 1) / x &amp;#43; ((K - 1) \% x) \times D) \% N
\) となる。
E
思ったより面倒だった。$A_i$と$A_j(i&amp;lt;j)$ が対応するような連続部分列は $\min(i, N - j + 1)$ 個なのでこれを全力で数え上げるか&amp;hellip;という気分になる。$i \leq N - j + 1$ の場合と$i &amp;gt; N - j + 1$ の場合に分けて考える。</description></item><item><title>ABC291 参加記</title><link>https://ikefumy.github.io/docs/1677421396/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1677421396/</guid><description>結果
TOEFLの対策とABCどっちやるか迷ってABCやった。
苦しい結果になった。
コンテストのURL
振り返り
A
やる。'A' &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= 'Z'の部分はなにかしらのかたちでテンプレにぶち込んでいいのかなと思いながら実装してた。けどテンプレがでかくなりすぎるのが個人的にあんまり好きじゃないので悩む。
追記: isupperについて twitterでdrogskolさんにisupperなる関数がstdに既に存在していることを教えてもらった。
https://t.co/Dx8Y6fJVY8
isupper は std にあります
&amp;mdash; drogskol (@cureskol) February 26, 2023 このほかtoupperなど様々な便利関数があるらしい( locale - cpprefjp C++日本語リファレンス)。どこかの解説放送でisdigit関数だけ見たことがあり、それだけ知ってた。テンプレを膨らませなくて良くなったので嬉しい。
B
ソートして平均取る。こういうのかいてるときrepマクロを整備しといて良かったって気分になる。
C
めんどい。移動をシミュレーションしながら座標をsetに入れて最後にsetのサイズを見ればいい。LRUDをそれぞれ0123に対応させたり進行方向に変換させたりしてくれる何かを持っていた方がいいかもしれん、とちょっと思った。
D
DPした。添え字をA[(表裏)][(カードの番号)]にしたせいでネストの順番と添え字の順番が逆なってしまい、きもいな&amp;hellip;直そうかな&amp;hellip;と悩んでるうちに実装が終わった。
E
トポソして、それが一意か見ればいいだけ。トポソをするときにqueueを使っているのでqueueのサイズが常に $1$ であることを確認する方針が最初に浮かんだ。入力を書いてる内に、どうせならqueue使わないで現在の頂点を保存する変数を1つだけもてばいいか？と思い、そっちを書き始めたが、書いてるうちに場合分けがだるそうな気がしてきたので最初の方針に戻した。
F
\[
\begin{aligned}
pre[i] &amp;amp;= 都市1から都市iまで移動するのに必要な最少のテレポート回数\\
pos[i] &amp;amp;= 都市iから都市Nまで移動するのに必要な最少のテレポート回数
\end{aligned}
\] を求める。$pre[i]$ は配るDPで、$pos[i]$ は貰うDPで書けばいい。後は $i \rightarrow j$ のワープが存在するなら各 $k (i&amp;lt; k &amp;lt; j)$ に対して $ans[k] \leftarrow \min(ans[k], pre[i] + pos[j] + 1)$ と更新するようにすれば答えが求まる。これ書いて提出したらWAがでて謎すぎた。しばらく眺めてみると $pre, pos$ をint型でとっていた上1 &amp;lt;&amp;lt; 30で初期化してたせいで、どちらも1 &amp;lt;&amp;lt; 30の時にオーバーフローしてた。intからlong longに直したらACした。</description></item></channel></rss>