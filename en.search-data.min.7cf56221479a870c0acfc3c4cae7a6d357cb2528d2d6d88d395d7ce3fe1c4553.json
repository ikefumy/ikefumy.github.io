[{"id":0,"href":"/docs/1676803816/","title":"ABC290","section":"ABC","content":"\r結果\rUS配列で参加する二回目のコンテスト。まだタイピングがおぼつかなくて、=を入力したかったのに_を入力してしまったり、*の位置が分からなくなったりする。 久々の三桁順位で萎えた。\nコンテストのURL\n振り返り\rA\rやるだけ。指の体操\nB\rK-- \u0026gt; 0で判定すると楽な気がする。\nC\r最初は$A$をソートしたりuniqueしたりしようとしてたけど、set使った方が楽なのでそっちに変更して書いた。\nD\r予選仕様なだけあってちょっとむずい気がしたけどqual Aよりはマシな難易度してた気がする。qual AのDは解法思い浮かぶまで時間かかったけどこれはすぐ浮かんだので。問題文を理解するのにちょっと時間がかかったけど用は$D$ずつ飛び飛びで塗って、同じ所に戻ってきたらずれるだけか～とわかった。マス$0$を出発した後、次にマス$0$に到達する時を$x$回目だとすると、$x \\times D \\equiv 0 \\pmod N$ が成り立つ。よって $x \\times D = \\operatorname{lcm}(D, N)$ となり、変形すると $x = N / \\gcd(D, N)$ となる。よって答えは \\(\r((K - 1) / x \u0026#43; ((K - 1) \\% x) \\times D) \\% N\r\\) となる。\nE\r思ったより面倒だった。$A_i$と$A_j(i\u0026lt;j)$ が対応するような連続部分列は $\\min(i, N - j + 1)$ 個なのでこれを全力で数え上げるか\u0026hellip;という気分になる。$i \\leq N - j + 1$ の場合と$i \u0026gt; N - j + 1$ の場合に分けて考える。\n$i \\leq N - j + 1$ の時、「$A_{i+1}\\sim A_{N-i+1}$ に含まれる $A_{i}$ と等しくない要素の個数」が分かれば良さそう。これをするには外部に $$ cnt[i]=(現在考えている区間に含まれているiの個数)$$ という配列を用意する。初めに全体に対して初期化しておく。その上で$i$を昇順に見ていき、\n答えに $(N - 2 \\times i + 2 - cnt[A[i]]) \\times i$ を加算。 $cnt[A[i]]$ と $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 とすればよい。$i \u0026gt; N - j + 1$ の場合も同様にすればよいが、この場合では等号がついていないので、デクリメントのタイミングが少し違い、\n$cnt[A[i]]$から$1$を引く。 答えに $(N - 2 \\times i + 1 - cnt[A[N - i + 1]]) \\times i$ を加算。 $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 とすればよい。これを書いて提出してAC。( 解説)\nF\rむっずい。マルチケースのくせして「$N$の総和は$1000000$を超えない」みたいな制約が無いので、漸化式があるか$O(1)$があるんだろうなという気分になる。$O(1)$ならOEISとかwolfram alphaで解けちゃうから漸化式かな～と考えた。今思うと漸化式も全然OEISで出てくる気がする。OEIS使ったこと全然無いので分からない。\nまずどんな数列のとき対応する木が作れるのか考えると、とりあえず全ての和が$2N-2$で、各次数が$1$以上$N-1$以下であるなら大丈夫そう。あるvalidな正整数列 $X$ に対する $f(X)$ はどれくらいかを考える。これは少し時間がかかったが、次数が$1$の頂点を両端に置き、間に次数$2$以上の頂点を並べれば良さそう。つまり$(次数2以上の頂点の数)+1$が最長の直径になる。漸化式なら$N+1$個目の頂点を追加した時の変化を観察すればええやろ！といろいろやった。長さがどう伸びるとか、通り数を管理すれば良いんじゃないか？とかやったが、数列が後から重複したり、次数が$1$の頂点の個数で分けて管理したくなったりして無理そうだった。\n漸化式よくわからんから$O(1)$も考えることにした。これも苦戦したが、そもそも全部の頂点の次数は$1$以上なんだから最初に全部配ってみることにした。そうすると残る次数は$N-2$であり、これをどんな分配しても次数の最大値が$N-1$を超えることは無い。ここら辺になってようやく光明が見えた気がしてきた。後は $\\displaystyle\\sum_{i=0}^{N-2}\\binom{N-2+i-1}{i-1} \\times (i+1)$ を計算すれば良さそうだが、これではマルチテストケースに対応できない。よく考えると主客転倒が出来て、「最初 $f(X)$ は $1$ で自分の次数が2以上なら $+1$ される」みたいな言い換えができる。よってある頂点に注目して、とりあえずその頂点に次数 $1$ を配って、残りの$N-3$を$N$個に分ければよい。これは $\\displaystyle\\binom{2N-4}{N-1}$ 通りである。この式は「$f(X)$を$1$で初期化した時からの追加分」を考えているので、初期化分を足す必要があること、注目する頂点は$N$通りであることに注意すると答えは $\\displaystyle{\\binom{2N-3}{N-1}+\\binom{2N-4}{N-1}\\times N}$ となる。$N=5$くらいならすぐ計算できるので計算して合ってることを確認してから書き始めた。自前の組合せライブラリを使ったけど、$1000010$で初期化したせいで1ペナついた。バカすぎ。\nG\rこのとき残り30分くらいだったので急いで考えた。こんなん沢山切れるとこから切るだけじゃんと思い、頂点の数が$X$を超える最少の高さの$K$分木を考えるだけの実装をした。WAが出てめっちゃ焦った。考察はミスってないし、ハックケースも浮かばないから実装ミスだと判断して実装ミスを探してたらコンテストが終わった。\n感想\r7完したかった\u0026hellip;。 最初は「慣れないUS配列で参加したからな、JIS配列だったら7完だったわ」みたいな言い訳を考えてたんだけど、Gをupsolveするのにめっちゃ時間がかかったので、JIS配列で出てても6完だったな…という気持ちになった。Gみたいな貪欲しつつ全探索する問題、いつまでたっても出来るようにならない。多分高校生の頃からずっと苦手で慣れない。貪欲法なら貪欲だけして終わり！という気分になって貪欲っぽくないところも貪欲でええか！ｗをしてしまいがちになる。ちゃんと証明をするか、怪しいケースを考えるべきだと感じた。今回なら「深さが3とか4のときに本当に最初に潜っていいか分からんな\u0026hellip;提出してWA出してから考えればいいか～」と思ってて、実装してる内に忘れてた。バカすぎ。\nDは1000diffちょっと超えてる位で、qual AのDは青diffだったのでやっぱり簡単になってた。Eはちょっと面倒だったので青かなぁと思ってたら水diffだった。解説を見ると結構簡単な実装をしてたので、僕が回り道をしてしまった感がある。あとFで詰めきれなくて死にそうになったが、ちゃんと詰めきれたのは良かった。数え上げ系は解けるとすっきりするので好き。数式の変形で殴るのは無理そうだと思って考察いろいろしてACしたけど数式の変形でも行けるらしくてビックリ。wolfram alphaを使うと楽にできるってのもビックリした。OEISとかwolframあたり、使いこなせない。\n次は7完したい。\nupsolve\rG\r本番投げた奴のどこが間違ってるか分からなくて、twitterで助けを求めたらcarrot46さんが教えてくれた。感謝。\n1\n4 2 9\nに3を返しますが、正しくは2です（根+根の子+根の子の子による部分木(頂点数7)を残すのが最適）\n\u0026mdash; carrot46 (@carrot46_kyopro) February 19, 2023 これ見る限り、根を使う場合は親とのつながりを切る必要が無いので、それだけ試せば良さそう。けどそれだけでええんか？と不安になり、念のため全ての部分木を試してみたらACした。 ACコード\n本解説を見たら解説1が僕の方法と同じだった。解説2の次数和に注目する方法はなるほど～となった。\n"},{"id":1,"href":"/docs/1676882511/","title":"E","section":"ABC290","content":" 問題のURL\n問題概要\r問題URL先を参照してください。\n解法\rどのような場合が答えに寄与するか考える。これは $A_i$と$A_j(i\u0026lt;j)$ が違い、かつそれらを対応付ける連続部分列が存在する場合である。$i, j$を固定した時、これらを対応付けるような連続部分列は $\\min(i, N - j + 1)$ 個である。よって $A_i\\neq A_j$ となるペア $(i, j)$ についてこれの和を求めればよい。 $i \\leq N - j + 1$ の場合と$i \u0026gt; N - j + 1$ の場合に分けて考える。\n$i \\leq N - j + 1$ の時、$i$を固定して$j$を動かしてるように考えればいいが、「$A_{i+1}\\sim A_{N-i+1}$ に含まれる $A_{i}$ と等しくない要素の個数」が分かれば良い。これをするには外部に $$ cnt[i]=(現在考えている区間に含まれているiの個数)$$ という配列を用意する。なお、初めは区間を全体として初期化しておく。その上で$i$を昇順に見ていき、\n答えに $(N - 2 \\times i + 2 - cnt[A[i]]) \\times i$ を加算。 $cnt[A[i]]$ と $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 とすればよい。要するに、区間$[i, N-i+1]$を考えた後、$i$番目と$N-i+1$番目の情報を削ることで区間$[i+1,N-i]$の情報に更新する、ということを繰り返している。\n$i \u0026gt; N - j + 1$ は$j$を固定して$i$を動かしているように考えればよい。ここでは$j=N-i+1$としている。この場合も先ほど大体同じだが、等号がついていないので、デクリメントのタイミングが少し違い、\n$cnt[A[i]]$から$1$を引く。 答えに $(N - 2 \\times i + 1 - cnt[A[N - i + 1]]) \\times i$ を加算。 $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 となる。一番最初にデクリメントすることで考えている区間が$[i+1, N-i+1]$になる。\nコード\r#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int N, A[200010], cnt[200010]; int main() { int N; cin \u0026gt;\u0026gt; N; for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; A[i]; cnt[A[i]]++; } ll ans = 0; for (int i = 1; i \u0026lt;= N / 2; i++) { ans += 1ll * (N - 2 * i + 2 - cnt[A[i]]) * i; cnt[A[i]]--, cnt[A[N - i + 1]]--; } for (int i = 1; i \u0026lt;= N; i++) cnt[i] = 0; for (int i = 1; i \u0026lt;= N; i++) cnt[A[i]]++; for (int i = 1; i \u0026lt;= N / 2; i++) { cnt[A[i]]--; ans += 1ll * (N - 2 * i + 1 - cnt[A[N - i + 1]]) * i; cnt[A[N - i + 1]]--; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Submission\n備考\rABC290 参加記\n"},{"id":2,"href":"/docs/1676803850/","title":"E","section":"ECR143","content":" 問題のURL\n問題概要\r解法\rコード\rSubmission\n備考\r"},{"id":3,"href":"/docs/1676803810/","title":"ECR143","section":"Div. 2, ECR","content":"\r結果\r丁度キーボードが届いた日のコンテストだったので、US配列に慣れる良い機会だと思って参加した。\n思ったより出来たので満足。 EFあたりが「これマルチケースなんですか…？」って感じの問題で実装が結構苦しかった。\nコンテストのURL\n振り返り\rA\r図があるな～と思いながら読んでた。一方の文字列の上から取った連続部分列をリバースして他方の文字列にくっつける操作しか出来ないことを確認して、sとtをリバースした物をくっつけてRR, BBの個数を数えた。もしも1つだけならそこで区切ればよいが、2つあったらどう分けても同じ色が隣接する部分が出てくるのでダメ。\n思ったよりスムーズに考察出来た気がしたがACまで6分強かかっててびっくりした。\nB\r制約小さいからごり押し探索でもやるのかな？と思って考察してみたけど、これ $l_i=k$ を満たすような $i$ と $r_j=k$ を満たすような $j$ があればよくない？となり、提出してAC。あんまり制約小さいのが生きなかったので不安だったが、ひっかけみたいなもんだと思うことにした。\nC\r図の意味がよくわからなかったのでスルーした。おもったより難しくて焦った。前から見て行って「今どんな量の飲み物が残っているか」がうまく管理できればいいよねって感じがしたので、その方針を考えてみる。$i$ 番目の人について考えているとき、残っている飲み物それぞれから $b_i$ を引く必要があり、この処理で $0$ を下回る飲み物には特別な処理が必要になりそう。全体から同じ数引くのは無理なので下駄を履かせてpriority_queueで常勝！って感じになる。\n考察が終わってみると大典型だった。\nD\r今回の問題の中で一番素朴だと思った。うまく配置すれば各トライアングル内で2本の辺を使うことができる。このとき、赤2つ青1つのトライアングルが $n/6$ 個、赤1つ青2つのトライアングルが $n/6$ 個となるのでトライアングルごとの塗り分け方は $\\displaystyle \\binom{n/3}{n/6}$ 通りとなる。トライアングル内の色の塗り方は\nすべて同じ重さ → 3通り 重さが2種類で重い方が2つ → 1通り 重さが2種類で軽い方が2つ → 2通り 重さが3種類 → 1通り となるので、あとは全部掛け合わせて終わり。\nD解き終わって問題一覧に戻るとEFGのAC人数がG \u0026gt; F \u0026gt; Eの順番になってて、どれから解けばいいんだ…？となった。とりあえずE開いたら問題文が長かったのでFG解いてる人は問題文長いから後回しにしたんだろうと考え、順番通りEを解くことにした。\nE\r読むのだるかったが読んだ。爆発に必要なマナが増えるほどbasic spellの詠唱回数が減るから三分探索でもすんのかな？って思った。三分探索するとしたら結局爆破する位置によってbasic spellを何回唱えるか数える必要があるからこっち先に考えるか～という気分になる。\nある位置で爆破を起こした時、左を全消しするのに必要なマナと右を全消しするのに必要なマナが分かればよさそう。対称性があるので左を全消しにする場合だけ考える。昇順で見ていって $i$ 番目を考えているとき、「$i-1$番目を爆破したときに左を全消しするのに必要なコスト」からうまいこと計算出来ればいいなぁという気分になる。$h_{i-1} \u0026lt; h_{i}$ のときはそのまま引き継げばよいが、そうでない時は少し面倒。$h_{i-1}$ を $h_{i} - 1$ まで削る必要がある。さらに、これによって $h_{i-2}$ が爆破できるかも変わってきてしまう。どうしましょう…ってなって途方に暮れる。よく考えるとヘルスの差がずっと1の区間は先頭が削られたら後続も同じ分だけ減らさないといけない。よってこの処理はまとめられる。つまり連続してる区間を保存しておいて順番に見ていけば良く、これをやるにはstackが都合がいい。計算量を考えると、$i$ 番目を見ているとき、区間 $[i, i]$が追加されたと考える。これを元にstackの先頭を見て、削る必要があればpopして削り現在の区間に加える。削らなくてよいなら終了。と処理すれば追加された区間たちは高々1回popするだけで、popしない場合は各処理で一回ずつなので償却で $O(N)$ となる。\n実装するときは左を全消しするのに必要なコストを計算する関数を用意するとリバースしたやつ突っ込んで右も計算できるので楽。 こんな感じ コンテスト本番はこんなの書いてたけど、ちょくちょく無駄があります。\nvector\u0026lt;ll\u0026gt; calc(vector\u0026lt;ll\u0026gt; v) { int n = v.size(); stack\u0026lt;pll\u0026gt; st; st.push({v[0], v[0]}); vector\u0026lt;ll\u0026gt; ret(n, 0); rep(i, 1, n) { ret[i] = ret[i - 1]; ll lw = v[i], hi = v[i]; while (!st.empty()) { auto [l, h] = st.top(); if (h \u0026lt; lw) break; st.pop(); ret[i] += (l + h) * (h - l + 1) / 2; ll nlw = max(0ll, lw - h + l - 1); if (lw) ret[i] -= (lw - 1 + nlw) * (lw - nlw) / 2; lw = nlw; } st.push({lw, hi}); } return ret; } あとは三分探索するだけや！と思い、三分探索を書き始めそうになったが、まずbasic spellに狭義の単調性があるのか分からないし、そもそも三分探索しなくてもそれぞれの地点で爆破起こした時の最小コスト分かるじゃんとなった。たまたま方針が死ななかっただけなので、運が良かった。いざ提出していみるとWAが出てしまい、結構メンタルにきた。バグりそうな部分はわりとちゃんと確認してから提出したつもりだったのでどこでWAが起きたか見当がつかなかった。丁寧に確認したのは部分和とるとこなので、そこ以外を確認するとlong longであってほしい所が intになっていた。そこを直したらACになった。これでペナついたのしょうもなさ過ぎて悲しくなった。\nF\r最初チップが移動したら移動前の頂点は白色に戻ると思い込んでたけど、そんなことは無いらしい。ようはある頂点を端点とするパスを出来るだけ並列して沢山伸ばしたいってことっぽい。シミュレーションしてくのは流石に無理でしょって感じがした(衝突した時に伸ばしなおすんだろうけどどこに伸ばすかの宛てが無いのでむりそう)ので、どうにかしてパスの長さを決め打つことにした。最大と書いてあるので二分探索やね、となり二分探索してそれぞれのパスの長さを固定した。そうすると後は木DPをするだけで良い。\n子からパスは伸びてきているか 子孫のうち、使えるパスの最大長はどれくらいか を考慮して衝突した場合などをうまく処理してAC。実装に結構手こずった。というか考察があまい状態で実装を始めたので場合分けやDFSでの戻り値をどうするかなどで時間を食ってしまった。\nG\rこの時点で残り22分だったので、「さすがにACまでは無理だな…」と思いつつとりあえず問題文を読んだ。これ全消し出来ない場合はどうするの？と思ったが、\nAdditional constraint on the input: there always exists at least one valid sequence of removals.\nと書いてあったので考えなくて良いらしい。この条件から現在除外可能な頂点は隣り合うことがなくて、貪欲に取っていくことで除去する頂点の順番を表すDAGが出来るので、あとは各頂点に関して「自分からは到達できないし、相手からも到達できない」ような頂点を数え上げれば良さそうだと思った。これ、頭が回ってなくてDFSで出来ると思ってたけど全然できない。本番はDFS全力で書いていたら時間切れになってしまった。\n今のところbitset使うくらいしか思いつかない。\n感想\r全体的におおまかな解法は結構すぐ浮かんだが、細部を考えずに突き進んだせいで実装でわちゃわちゃしてしまった。これは細部に嘘があった場合死ぬのであまり良くない。次回はしっかり詰めてから実装したい。JIS配列では書きやすかった記法がUS配列では指の動きが多くて大変ということが結構あったので、キーボードを変えるとコードの書き方も変わるようになるのかなと思った。あとEFは関数を多用したくて、そうなるとグローバル変数として全部置くのが楽なんだけどマルチケースなので初期化が必要になり、めんどいな…という気分になった。ラムダ式に感謝。\n最近のDiv2、毎回全完一歩手前で終わっちゃう。一回くらい全完してみたい。\nupsolve\rそのうちやります。\n"},{"id":4,"href":"/docs/books/patahene/","title":"パタヘネ 第6版","section":"参考書","content":"\r概要\rここにはにはコンピュータの構成と設計 第6版の僕の解答を載せます。\n"},{"id":5,"href":"/docs/contests/","title":"参加記","section":"Docs","content":"主にAtCoderやCodeforcesの参加記を書きます。基本的に本番の記録に使いますが、upsolve時の感想やシステスの感想なども書くかもしれません。また、面白いと思った問題は参加記とは別に解説を書いて見たいと思っています。\n"},{"id":6,"href":"/docs/editorial/","title":"解説","section":"Docs","content":"\r解説\rここでは面白いと思った問題の解説や、解説が難解だと感じた問題の自分なりの解釈書きます。\n"},{"id":7,"href":"/docs/books/","title":"参考書","section":"Docs","content":"\r参考書\rここには解説が載っていない参考書の自分なりの解答を書きます。ただし、分からない問題は欄だけ作成し、放置しておきます。間違いや、空白となっている問題の答えが分かった場合はtwitterのDMやGitHubのissueなどで教えてくれるととてもありがたいです。\n連絡先\n"}]