<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>参加記 on ikefumy's memo</title><link>https://ikefumy.github.io/categories/%E5%8F%82%E5%8A%A0%E8%A8%98/</link><description>Recent content in 参加記 on ikefumy's memo</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://ikefumy.github.io/categories/%E5%8F%82%E5%8A%A0%E8%A8%98/index.xml" rel="self" type="application/rss+xml"/><item><title>Codeforces #854 (Div.1 + Div. 2) 参加記</title><link>https://ikefumy.github.io/docs/1677520903/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1677520903/</guid><description>結果
TOEFL iBTの対策をするかコンテストに参加するか迷って結局参加した。
三時間かけてレートを36溶かすことができました。
コンテストのURL
振り返り
A
普通に実装するだけだった。
B
最初は $2$ をどうにかして作ってそれで全てを割ればいいんじゃないか？と思い、どうにか $2$ を作ろうと頑張るが、色々と場合分けが発生して大変だった。最初に最大と最少を持ってきて適宜交換しながら割っていく方法を試してみたが、出来ず、毎回最大最小持ってきてそれらが同じになるまで割れば良さそうなことに気付いた。計算量が $O(tn^2)$ だから間に合わないかもしれん、と思って別の手を考えようとしたが、何も浮かばなかったので諦めて先ほどの考察を実装したら爆速で通って謎だった。出力をミスってて1WAでたが、Wrong answer on pretest 1だったのでペナがつかなかった。
今見返したら
It is guaranteed, that the sum of $n$ for all test cases does not exceed $1000$ .
って書いてあって、なるほどね、って感じがした。
C
むずすぎる。こんなん $a$ から順番に外側から並べて、文字の個数が奇数個の時はより大きい文字とペアにして、大きい方を手前、そうでない方を奥にして、余ったやつを小さいやつから前に貪欲に置いていけば終わり！と思って実装。Exampleいれて確認したら
abb が
bba になってた。これはどうしようかな&amp;hellip;と思い色々考えた。奇数個存在するアルファベットがある、かつ、文字列の長さが奇数なら真ん中にそいつおいて残りで同じことすればいいんじゃね？と思ったが、実装だるそうだしbbccaで死ぬ。色々考えて奇数個存在するアルファベットがあり、それより大きいアルファベットの種類数が $1$ 個なら奇数個のやつを真ん中おいてそれ以外を大きい方のアルファベットでうめる、そうでないなら先ほどの実装をすればよさそうと考え、これを実装して提出してAC。テストケースの丁寧さに助けられた。
D1
とりえあえず \[
dp[(今の場所)][(1つ目のCPUの最後に実行したプログラム)][(1つ目のCPUの最後に実行したプログラム)]
\] は計算量的にダメで、1つ手前のプログラムは必ずどちらかのCPUに使われるので次元が落せて、終わり！となり実装し始める。しかし「連続して同じプログラムを実行した場合最後の実行だけ $hot_i$ かかり、それ以外は $cold_i$ かかる」という問題だと勘違いしていたため、最後に実行したプログラムが $hot$ であったか否かを記録する次元も必要だと考え、 \[
dp[(今の場所)][(i-1を実行していないCPUの最後に実行したプログラム)][i-1はhotで実行されたか][第二引数のプログラムはhotで実行されたか]
\] みたいなDPを書いた。めっちゃ大変だったが、何とか書き上げ、サンプルを入れたら全然違くて絶望した。なぜか小さくなっているサンプルもあったのでマジで謎だったが、入力を間違えてた。僕は毎行 $cold_i, hot_i$ が与えられ、それが $n$ 行続くと思っていたが、実際は一行目に $cold$, 二行目に $hot$ が与えられていた。これを書き直してACやろ！と思ったけどまだダメ。サンプルを眺めると</description></item><item><title>Codeforces #855 参加記</title><link>https://ikefumy.github.io/docs/1677819673/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1677819673/</guid><description>
結果
ペナ多すぎ。
コンテストのURL
振り返り
A
ただの足し算みたいな問題が来ると思ってたら思ってたより面倒な問題が来た。色々考えたが、まずは文字列 $s$ の要素を全て小文字にしてs.erase(unique(s.begin(), s.end()), s.end())でランレングス圧縮して、s == &amp;quot;meow&amp;quot;を見ることにした。これを書いてAC。
B
それぞれのアルファベットにおいて、小文字の数と大文字の数を数えておく。アルファベット $i$ における小文字の数を $small_i$, 大文字の数を $large_i$ として、答えに $\min(small_i, large_i)$ を足した後、$\min(k, |small_i, large_i| / 2)$ を答えに足す。またこの値を $k$ から引く。とやればいいだけ。
C1
なんか適当にDPするんでしょう、って感じだったが、面倒そうなのでC2解いてからその提出をC1になげればいいか、と考えC2に向かった。
C2
配列を左から走査し、$a_i&amp;gt;0$ ならpriority_queueに降順でつめこみ、0ならpriority_queueの先頭を答えに加算してポップする。ポップしたやつが前回の奴より後の要素だったとしたら前回の奴と自分の取ったカードを逆に取ったと考えるようにすればよい。一応C2のACを確認してからC1に投げた。
D
よくわからないからロリハを持ち出した。文字列を繋げるのに苦戦しつつ提出したらWAがでて「デバッグ嫌すぎ&amp;hellip;」ってなった。いろいろ入れてみて最終的に、ハッシュ値を詰め込むsetがint型で定義されているせいだった。これをlong longに直してAC。
E1
$k=3$とか関係なしに互いにswapで到達できうる頂点集合ごとに分けて、この頂点集合の値を添え字とする $s$, $t$ のアルファベットの多重集合が等しければいいのでは？と思った。$k=3$ だから使える解法ってのがパッと浮かばなかったが、ひとまずE2みて、それのACコードをE1に投げることにしてE2に向かった。
E2
問題文を読んだが、E1で書いた考察で間違いなさそう。BFSなどで先ほどの考察を実装しAC。
F
結構悩んだ。最初は「どのアルファベットが存在するか」と「奇数個あるアルファベットであるか」をbitで表して上手い事処理するのかと考えたが、無理そう。OKとなるのは二つの文字列の「奇数個あるアルファベット」の値をxorしたものpopcountが25であるときで、このとき必ず文字列の長さは奇数になっている。ここで、bitの値が0のアルファベットは存在しないからOKか！という謎の勘違いをしたため1WA。よく考えたらそんなことは無いので、mapを26個つくって、$i$ 個目のmapには「 $i$ 番目のアルファベットが存在しない文字列のbit表現の値」を入れておく。あとはそれぞれの文字列についてどのアルファベットを使わないかを全探索して、適切なmapから値を取り出して答えに加算すれば良い。これ書いて出したらTLEした。mapはアクセスしたときにそのキーが存在しなかったら勝手に作ってしまうので、そのせいでサイズがでかくなりTLEしてるっぽい。場合分けしてキーが存在しない時はアクセスしないようにしてAC。
G
ひとまずうまく探索する方法を考えたが、特に浮かばない。そういえば木のハッシュという物を聞いたことがあるな～と思い、検索したら この記事を見つけた。ロリハライブラリからハッシュ計算だけ抜き出してこれに書いてある通りに木のハッシュを実装し、根から順番に子のハッシュを列挙し、奇数個あるハッシュ値が0個ならその時点で終了。1個ならそのハッシュ値を持っている子のうちの1つに遷移、2個以上なら答えをNOとして終了、という実装をした。これを提出したらWAがでた。木のハッシュの実装ミスを疑い確認したが特にミスはない。いろいろテストケースを入れてたら以下のケースがYESと判定された。
4 1 2 1 3 3 4 ハッシュを用いて対称かを判定する段階で「奇数個あるハッシュ値が2個以上」の部分の等号が抜けており、「奇数個あるハッシュの値が2個より多いとき」になっていた。これに等号をつけてAC。
感想
問題文が難読だった。あと思っていたより難しかったので焦った。この難易度でもケアレスミスでペナ出しまくったので若干悲しい。G問題で初めて木のハッシュの実装を知ったんだけど、これでちゃんとしたハッシュになるのすごくて感動した。暇なときにちゃんと勉強したい。
upsolve</description></item><item><title>yukicoder contest 378 参加記</title><link>https://ikefumy.github.io/docs/1677308496/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1677308496/</guid><description>結果
初めてyukicoderのコンテストに参加した。 7完で33位だった。ペナ9個もあってすごい。
コンテストのURL
振り返り
A
問題文の通り場合分けして実装するだけ。atoiを使おうとしてそのままstring型の変数入れたら怒られた。char *型しか許してくれないらしい。.c_strを使い事なきを得た。
B
これも問題文の通りに実装するだけ。愚直に書くと $O(HWK)$ だけど、制約が制約なので間に合う。
C
嘘生やしまくった。最初は先頭から愚直にマッチングしていってhelloworldを埋め込める場所を見つけたら残りの部分にaを埋め込めば良いと思ったが、WA。よく考えたら後ろからじゃね？と思い後ろからマッチングしてみたけどWA。もっとよく考えるともともとhelloworldが埋め込まれているのなら全ての?をaで置換するのが最適&amp;hellip;？と考えたがこれが嘘でまたWAが出たら流石に苦しいので愚直に全通り試してソートして一番小さいやつを出力した。
D
これは実装ミスでWAを生やしていた。横パンチの回数を固定して縦パンチの回数を二分探索すればよさそうなのは割とすぐわかって実装したらWAがでた。最初は考察が違うのかと思って考察し直そうとしたが、特にヤバそうな点がなかったので次に実装ミスを探すことにした。オーバーフローとか二分探索の上限下限当たりを調べたけど特に問題無さそうだった。ここでもう一回考察ミスを考えなおした。横パンチの回数は最大でも $H$ 回だと思ってたけど、そうでもなくて $H+W$ 回が上限やん、と気づき、書き直して提出したがまだWAだった。いよいよなんでWAなのか分からなくてしばらく絶望してた。
何回も確認した末、制約を見誤ってることに気づいた。 $0 \leq K_A, K_B \leq HW$ なので $K_A, K_B$ は最大で $10^{12}$ になるんだけど、なぜか $10^6$ が最大だと思ってた。ここが原因でWAが出ていたのでそこを書き直してやっとACした。
E
AC数がFの方が多かったのでF解いてからEを解いた。手元で色々かいて良さげな方法を探した。途中から周期的な動きをしてくれると嬉しいな～と思いながら色々実験した結果、DDDRRRRUのあとは外周をクルクルまわる感じで対処出来る事に気が付いた。つまりUULL, LLDD, DDRR, RRUU, UULL, &amp;hellip;と繰り返せば良い。これをそのまま実装してACした。
F
これも誤読でめっちゃWAを生やした。まず条件式から「こんなん45度回転ですやん」って気持ちになる。制約を見間違え $HW \leq 2 \times 10^5$ だと思っていたので行方向に走査してセグ木で管理する感じか～となる。これ書いて提出したらMLEでて仰天した。とりあえずセグ木に投げるクエリの保存方法を変えたりセグ木ではなくFenwick treeを使ってみたり、mintではなくlong longを使ってみたりしたがすべてMLE。よくわかんなくなって結構絶望した。いろいろ考えた後制約見直したら$HW \leq 2 \times 10^5$ じゃなくて目を疑った。 $\max(HW, 2 \times 10 ^ 5)$ の部分でとなり合ってる要素を都合よく解釈してたのバカすぎて面白い。この制約でも上手い事やれば今の方針でいけるのかな～と思ってちょっと考えたけど、面倒なことになりそうだったので方針を変えた。宝の数が高々 $2 \times 10 ^ 5$ 個なので主客転倒してそれぞれの宝についてその宝をゲットできるマスの数を数え上げることにした。これは下図のようになる。</description></item><item><title>ABC290 参加記</title><link>https://ikefumy.github.io/docs/1676803816/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1676803816/</guid><description>結果
US配列で参加する二回目のコンテスト。まだタイピングがおぼつかなくて、=を入力したかったのに_を入力してしまったり、*の位置が分からなくなったりする。 久々の三桁順位で萎えた。
コンテストのURL
振り返り
A
やるだけ。指の体操
B
K-- &amp;gt; 0で判定すると楽な気がする。
C
最初は$A$をソートしたりuniqueしたりしようとしてたけど、set使った方が楽なのでそっちに変更して書いた。
D
予選仕様なだけあってちょっとむずい気がしたけどqual Aよりはマシな難易度してた気がする。qual AのDは解法思い浮かぶまで時間かかったけどこれはすぐ浮かんだので。問題文を理解するのにちょっと時間がかかったけど用は$D$ずつ飛び飛びで塗って、同じ所に戻ってきたらずれるだけか～とわかった。マス$0$を出発した後、次にマス$0$に到達する時を$x$回目だとすると、$x \times D \equiv 0 \pmod N$ が成り立つ。よって $x \times D = \operatorname{lcm}(D, N)$ となり、変形すると $x = N / \gcd(D, N)$ となる。よって答えは \(
((K - 1) / x &amp;#43; ((K - 1) \% x) \times D) \% N
\) となる。
E
思ったより面倒だった。$A_i$と$A_j(i&amp;lt;j)$ が対応するような連続部分列は $\min(i, N - j + 1)$ 個なのでこれを全力で数え上げるか&amp;hellip;という気分になる。$i \leq N - j + 1$ の場合と$i &amp;gt; N - j + 1$ の場合に分けて考える。</description></item><item><title>ABC291 参加記</title><link>https://ikefumy.github.io/docs/1677421396/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1677421396/</guid><description>結果
TOEFLの対策とABCどっちやるか迷ってABCやった。
苦しい結果になった。
コンテストのURL
振り返り
A
やる。'A' &amp;lt;= c &amp;amp;&amp;amp; c &amp;lt;= 'Z'の部分はなにかしらのかたちでテンプレにぶち込んでいいのかなと思いながら実装してた。けどテンプレがでかくなりすぎるのが個人的にあんまり好きじゃないので悩む。
追記: isupperについて twitterでdrogskolさんにisupperなる関数がstdに既に存在していることを教えてもらった。
https://t.co/Dx8Y6fJVY8
isupper は std にあります
&amp;mdash; drogskol (@cureskol) February 26, 2023 このほかtoupperなど様々な便利関数があるらしい( locale - cpprefjp C++日本語リファレンス)。どこかの解説放送でisdigit関数だけ見たことがあり、それだけ知ってた。テンプレを膨らませなくて良くなったので嬉しい。
B
ソートして平均取る。こういうのかいてるときrepマクロを整備しといて良かったって気分になる。
C
めんどい。移動をシミュレーションしながら座標をsetに入れて最後にsetのサイズを見ればいい。LRUDをそれぞれ0123に対応させたり進行方向に変換させたりしてくれる何かを持っていた方がいいかもしれん、とちょっと思った。
D
DPした。添え字をA[(表裏)][(カードの番号)]にしたせいでネストの順番と添え字の順番が逆なってしまい、きもいな&amp;hellip;直そうかな&amp;hellip;と悩んでるうちに実装が終わった。
E
トポソして、それが一意か見ればいいだけ。トポソをするときにqueueを使っているのでqueueのサイズが常に $1$ であることを確認する方針が最初に浮かんだ。入力を書いてる内に、どうせならqueue使わないで現在の頂点を保存する変数を1つだけもてばいいか？と思い、そっちを書き始めたが、書いてるうちに場合分けがだるそうな気がしてきたので最初の方針に戻した。
F
\[
\begin{aligned}
pre[i] &amp;amp;= 都市1から都市iまで移動するのに必要な最少のテレポート回数\\
pos[i] &amp;amp;= 都市iから都市Nまで移動するのに必要な最少のテレポート回数
\end{aligned}
\] を求める。$pre[i]$ は配るDPで、$pos[i]$ は貰うDPで書けばいい。後は $i \rightarrow j$ のワープが存在するなら各 $k (i&amp;lt; k &amp;lt; j)$ に対して $ans[k] \leftarrow \min(ans[k], pre[i] + pos[j] + 1)$ と更新するようにすれば答えが求まる。これ書いて提出したらWAがでて謎すぎた。しばらく眺めてみると $pre, pos$ をint型でとっていた上1 &amp;lt;&amp;lt; 30で初期化してたせいで、どちらも1 &amp;lt;&amp;lt; 30の時にオーバーフローしてた。intからlong longに直したらACした。</description></item><item><title>ECR143 参加記</title><link>https://ikefumy.github.io/docs/1676803810/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1676803810/</guid><description>結果
丁度キーボードが届いた日のコンテストだったので、US配列に慣れる良い機会だと思って参加した。
思ったより出来たので満足。 EFあたりが「これマルチケースなんですか…？」って感じの問題で実装が結構苦しかった。
コンテストのURL
振り返り
A
図があるな～と思いながら読んでた。一方の文字列の上から取った連続部分列をリバースして他方の文字列にくっつける操作しか出来ないことを確認して、sとtをリバースした物をくっつけてRR, BBの個数を数えた。もしも1つだけならそこで区切ればよいが、2つあったらどう分けても同じ色が隣接する部分が出てくるのでダメ。
思ったよりスムーズに考察出来た気がしたがACまで6分強かかっててびっくりした。
B
制約小さいからごり押し探索でもやるのかな？と思って考察してみたけど、これ $l_i=k$ を満たすような $i$ と $r_j=k$ を満たすような $j$ があればよくない？となり、提出してAC。あんまり制約小さいのが生きなかったので不安だったが、ひっかけみたいなもんだと思うことにした。
C
図の意味がよくわからなかったのでスルーした。おもったより難しくて焦った。前から見て行って「今どんな量の飲み物が残っているか」がうまく管理できればいいよねって感じがしたので、その方針を考えてみる。$i$ 番目の人について考えているとき、残っている飲み物それぞれから $b_i$ を引く必要があり、この処理で $0$ を下回る飲み物には特別な処理が必要になりそう。全体から同じ数引くのは無理なので下駄を履かせてpriority_queueで常勝！って感じになる。
考察が終わってみると大典型だった。
D
今回の問題の中で一番素朴だと思った。うまく配置すれば各トライアングル内で2本の辺を使うことができる。このとき、赤2つ青1つのトライアングルが $n/6$ 個、赤1つ青2つのトライアングルが $n/6$ 個となるのでトライアングルごとの塗り分け方は $\displaystyle \binom{n/3}{n/6}$ 通りとなる。トライアングル内の色の塗り方は
すべて同じ重さ → 3通り 重さが2種類で重い方が2つ → 1通り 重さが2種類で軽い方が2つ → 2通り 重さが3種類 → 1通り となるので、あとは全部掛け合わせて終わり。
D解き終わって問題一覧に戻るとEFGのAC人数がG &amp;gt; F &amp;gt; Eの順番になってて、どれから解けばいいんだ…？となった。とりあえずE開いたら問題文が長かったのでFG解いてる人は問題文長いから後回しにしたんだろうと考え、順番通りEを解くことにした。
E
読むのだるかったが読んだ。爆発に必要なマナが増えるほどbasic spellの詠唱回数が減るから三分探索でもすんのかな？って思った。三分探索するとしたら結局爆破する位置によってbasic spellを何回唱えるか数える必要があるからこっち先に考えるか～という気分になる。
ある位置で爆破を起こした時、左を全消しするのに必要なマナと右を全消しするのに必要なマナが分かればよさそう。対称性があるので左を全消しにする場合だけ考える。昇順で見ていって $i$ 番目を考えているとき、「$i-1$番目を爆破したときに左を全消しするのに必要なコスト」からうまいこと計算出来ればいいなぁという気分になる。$h_{i-1} &amp;lt; h_{i}$ のときはそのまま引き継げばよいが、そうでない時は少し面倒。$h_{i-1}$ を $h_{i} - 1$ まで削る必要がある。さらに、これによって $h_{i-2}$ が爆破できるかも変わってきてしまう。どうしましょう…ってなって途方に暮れる。よく考えるとヘルスの差がずっと1の区間は先頭が削られたら後続も同じ分だけ減らさないといけない。よってこの処理はまとめられる。つまり連続してる区間を保存しておいて順番に見ていけば良く、これをやるにはstackが都合がいい。計算量を考えると、$i$ 番目を見ているとき、区間 $[i, i]$が追加されたと考える。これを元にstackの先頭を見て、削る必要があればpopして削り現在の区間に加える。削らなくてよいなら終了。と処理すれば追加された区間たちは高々1回popするだけで、popしない場合は各処理で一回ずつなので償却で $O(N)$ となる。</description></item><item><title>ECR144 参加記</title><link>https://ikefumy.github.io/docs/1677606331/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ikefumy.github.io/docs/1677606331/</guid><description>結果
あったので出た。
まあまあの出来。
コンテストのURL
振り返り
A
事前に適当な長さだけFB-stringを作って与えられた文字列がこれの部分列か見ればいいだけ。最初$30$までのFB-stringを作って提出したら長さが足りなくてペナが出た。
B
編集距離みたいにやったあと復元かな、と思ってDPするところまで書いて、嘘であることに気づいた。最大共通部分列を取ってくるのが最適とは限らない。よく考えたら先頭が一致してたらそれ以降を*、末尾が一致してたらそれ以前を*、どちらでもないなら共通する長さ $2$ の連続部分文字列があるならそれの前後に*、そうでないなら作れない。
C
なにこれ？集合内で自分の次に大きい要素はそいつで割り切れて、逆にそうなっているならbeautifulな集合になっている。よって $l\times 2^k \leq r$ を満たす最大の $k$ を取ってくるとこれがサイズの方の答えになる。またこれが集合の最大の要素を最小の要素で割った時の商になっている。あとは $3 \times 2^{k-1}$ の場合も考えればよい。$2$ の代わりに $4, 5, &amp;hellip; $ を使うことは絶対にできないのでこれで十分。例えば $2$ の代わりに $4$ をかけれるならサイズを $1$ 増やせるはず。これ絶対 $998244353$ こえなくね？って思ってしばらく確認してたけど、これで合ってそう。一応modint使って提出したらWAがでた。やっぱり考察ミスか？と思って考察し直したけどヤバい所は無さそう。実装を見直したら最大が最少の $3 \times 2^{k-1}$ 倍となる場合の計算において場合によっては答えが負になるような実装をしていた。これを直してAC。
D
大変だった。$i$ 番目を右端として、$i-k+1\sim i$ が左端となる場合を愚直に探索する。 左端が $i-k$ 以下となる場合はセグ木で対応すればよい。セグ木には $\displaystyle\sum_{k=0}^{i}a[i]-x\times i$ を入れておけばよい。$x$ が負の場合もこれで良いと思ってサンプル入れたら最後のケース ( $x$ が負の場合) だけ落ちた。もう一回考えたら確かに全然ダメだった。しょうが無いので負の場合も場合分けして実装する。 $x$ が負の場合はとりあえず 右端を $i$ として、もしも $n-i \geq k$ なら 区間の全てに $|x|$ を加算することができる。よって左端を好きに決めてよい。この計算は先ほどと同じようにできる。$n-i&amp;lt;k$ となるような $i$ は　$k-1$ 個で $k\leq 20$ なので、このような $i$ に関しては左端を全探索する。区間内で $+x$ されるような要素の数が最少になるようにすればよい。結構バグを埋め込んでしまったが、幸い提出前に全て修正でき、一発でAC出来た。</description></item></channel></rss>