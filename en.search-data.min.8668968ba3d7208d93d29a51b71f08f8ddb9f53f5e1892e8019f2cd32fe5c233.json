[{"id":0,"href":"/docs/1677520903/","title":"#854","section":"Div. 1 + Div. 2","content":"\r結果\rTOEFL iBTの対策をするかコンテストに参加するか迷って結局参加した。\n三時間かけてレートを36溶かすことができました。\nコンテストのURL\n振り返り\rA\r普通に実装するだけだった。\nB\r最初は $2$ をどうにかして作ってそれで全てを割ればいいんじゃないか？と思い、どうにか $2$ を作ろうと頑張るが、色々と場合分けが発生して大変だった。最初に最大と最少を持ってきて適宜交換しながら割っていく方法を試してみたが、出来ず、毎回最大最小持ってきてそれらが同じになるまで割れば良さそうなことに気付いた。計算量が $O(tn^2)$ だから間に合わないかもしれん、と思って別の手を考えようとしたが、何も浮かばなかったので諦めて先ほどの考察を実装したら爆速で通って謎だった。出力をミスってて1WAでたが、Wrong answer on pretest 1だったのでペナがつかなかった。\n今見返したら\nIt is guaranteed, that the sum of $n$ for all test cases does not exceed $1000$ .\nって書いてあって、なるほどね、って感じがした。\nC\rむずすぎる。こんなん $a$ から順番に外側から並べて、文字の個数が奇数個の時はより大きい文字とペアにして、大きい方を手前、そうでない方を奥にして、余ったやつを小さいやつから前に貪欲に置いていけば終わり！と思って実装。Exampleいれて確認したら\nabb が\nbba になってた。これはどうしようかな\u0026hellip;と思い色々考えた。奇数個存在するアルファベットがある、かつ、文字列の長さが奇数なら真ん中にそいつおいて残りで同じことすればいいんじゃね？と思ったが、実装だるそうだしbbccaで死ぬ。色々考えて奇数個存在するアルファベットがあり、それより大きいアルファベットの種類数が $1$ 個なら奇数個のやつを真ん中おいてそれ以外を大きい方のアルファベットでうめる、そうでないなら先ほどの実装をすればよさそうと考え、これを実装して提出してAC。テストケースの丁寧さに助けられた。\nD1\rとりえあえず \\[\rdp[(今の場所)][(1つ目のCPUの最後に実行したプログラム)][(1つ目のCPUの最後に実行したプログラム)]\r\\] は計算量的にダメで、1つ手前のプログラムは必ずどちらかのCPUに使われるので次元が落せて、終わり！となり実装し始める。しかし「連続して同じプログラムを実行した場合最後の実行だけ $hot_i$ かかり、それ以外は $cold_i$ かかる」という問題だと勘違いしていたため、最後に実行したプログラムが $hot$ であったか否かを記録する次元も必要だと考え、 \\[\rdp[(今の場所)][(i-1を実行していないCPUの最後に実行したプログラム)][i-1はhotで実行されたか][第二引数のプログラムはhotで実行されたか]\r\\] みたいなDPを書いた。めっちゃ大変だったが、何とか書き上げ、サンプルを入れたら全然違くて絶望した。なぜか小さくなっているサンプルもあったのでマジで謎だったが、入力を間違えてた。僕は毎行 $cold_i, hot_i$ が与えられ、それが $n$ 行続くと思っていたが、実際は一行目に $cold$, 二行目に $hot$ が与えられていた。これを書き直してACやろ！と思ったけどまだダメ。サンプルを眺めると\n5 1 1 1 1 1 1 1000000000 999999999 というサンプルを見つけた。これが$4999999996$になるのわけわからん\u0026hellip;なんで\u0026hellip;？と思いしばらく考えたがわからなかった。問題文読み返したら誤読してて、マジで絶望した。最初の考察で終わりじゃん\u0026hellip;となり、それ書いて通った。虚無。\nD2\rでかい制約で出来るんや～って気分になった。CPUの処理を飛び飛びに飛ばして行けば良さそうなんだけど最初なぜか「同じプログラムまで処理を飛ばす」ということしか考えてなくてそれを実装しようとしたんだけど、冷静になるとそんなことは無かった。処理するCPUが変わる部分だけに注目すれば適当にCPUを割り当てられるのでその方針で考える。$a_i, a_{i+1}$ で処理するCPUが違う時、$a_{i+1}$ は前のCPUと連続して実行されて～とか考えると、現在処理していないCPUの最後に実行したプログラムをセグ木におぼえておいてうまく更新していけばよさそう。まず初めに全部1つのCPUで実行したと仮定してコストを計算する。そして $i$ 番目と $i+1$ 番目が別のCPUで実行されていたと考えてコストを計算しなおした。これを書いたらWAがでて謎だった。良く眺めると更新する際に $hot$ になるとしたら $a_{i+1}$ なのになぜか $a_i$ の値を加算していた。書き直して提出したらRE。セグ木のサイズを $n+2$ で初期化していた。これを$k + 2$ に書き直したらWA。セグ木のサイズを直しただけで、アクセスするときの添え字が $n$ のままだった。これを書き直してAC。ペナが多すぎる。\nE\rあと1時間あるしEくらいなら通せると思ってた。 以下みたいなコの字型の配置がなければOKっぽい。\n### #.# 制約的にフローなのかなと思ってしばらくフローを考えてたけどいい物が浮かばず。あるマスが埋められてないのならそのマスから2方向は必ず空白が連続している必要があって、逆に2方向に空白が連続してるならそのマスは空白でよい、という案が浮かんだが、以下のような場合で死ぬ。\n..# ... #.. 残り20分を切ったあたりで、行方向の区間をもって列方向にDPという案を思いつき、これを全力で書いたが計算量が悪かったり、考慮出来ないパターンがあったりしてダメだった。\n感想\r制約見てない、テストケース見てない、誤読する、というミスを全部やったのバカすぎる。Eは解ける気しなかったが、解くスピードはもうちょっと上げれたんじゃないかという気がする。Eは時間が無さ過ぎて最悪多次元DPを書き始めたけどコンテスト後に嘘解法であることが分かったので虚無になった。冷静になると最近調子悪いのに何で出たんですか？って感じだが、まあ出たかったのでしょうがない。次からは丁寧に解くようにする。とりあえずテストケースみない癖がずっと抜けてないのでテストケースを一通り確認する癖を付けるようにする。\nupsolve\rそのうちやります。\n"},{"id":1,"href":"/docs/1677308496/","title":"378","section":"yukicoder","content":"\r結果\r初めてyukicoderのコンテストに参加した。 7完で33位だった。ペナ9個もあってすごい。\nコンテストのURL\n振り返り\rA\r問題文の通り場合分けして実装するだけ。atoiを使おうとしてそのままstring型の変数入れたら怒られた。char *型しか許してくれないらしい。.c_strを使い事なきを得た。\nB\rこれも問題文の通りに実装するだけ。愚直に書くと $O(HWK)$ だけど、制約が制約なので間に合う。\nC\r嘘生やしまくった。最初は先頭から愚直にマッチングしていってhelloworldを埋め込める場所を見つけたら残りの部分にaを埋め込めば良いと思ったが、WA。よく考えたら後ろからじゃね？と思い後ろからマッチングしてみたけどWA。もっとよく考えるともともとhelloworldが埋め込まれているのなら全ての?をaで置換するのが最適\u0026hellip;？と考えたがこれが嘘でまたWAが出たら流石に苦しいので愚直に全通り試してソートして一番小さいやつを出力した。\nD\rこれは実装ミスでWAを生やしていた。横パンチの回数を固定して縦パンチの回数を二分探索すればよさそうなのは割とすぐわかって実装したらWAがでた。最初は考察が違うのかと思って考察し直そうとしたが、特にヤバそうな点がなかったので次に実装ミスを探すことにした。オーバーフローとか二分探索の上限下限当たりを調べたけど特に問題無さそうだった。ここでもう一回考察ミスを考えなおした。横パンチの回数は最大でも $H$ 回だと思ってたけど、そうでもなくて $H+W$ 回が上限やん、と気づき、書き直して提出したがまだWAだった。いよいよなんでWAなのか分からなくてしばらく絶望してた。\n何回も確認した末、制約を見誤ってることに気づいた。 $0 \\leq K_A, K_B \\leq HW$ なので $K_A, K_B$ は最大で $10^{12}$ になるんだけど、なぜか $10^6$ が最大だと思ってた。ここが原因でWAが出ていたのでそこを書き直してやっとACした。\nE\rAC数がFの方が多かったのでF解いてからEを解いた。手元で色々かいて良さげな方法を探した。途中から周期的な動きをしてくれると嬉しいな～と思いながら色々実験した結果、DDDRRRRUのあとは外周をクルクルまわる感じで対処出来る事に気が付いた。つまりUULL, LLDD, DDRR, RRUU, UULL, \u0026hellip;と繰り返せば良い。これをそのまま実装してACした。\nF\rこれも誤読でめっちゃWAを生やした。まず条件式から「こんなん45度回転ですやん」って気持ちになる。制約を見間違え $HW \\leq 2 \\times 10^5$ だと思っていたので行方向に走査してセグ木で管理する感じか～となる。これ書いて提出したらMLEでて仰天した。とりあえずセグ木に投げるクエリの保存方法を変えたりセグ木ではなくFenwick treeを使ってみたり、mintではなくlong longを使ってみたりしたがすべてMLE。よくわかんなくなって結構絶望した。いろいろ考えた後制約見直したら$HW \\leq 2 \\times 10^5$ じゃなくて目を疑った。 $\\max(HW, 2 \\times 10 ^ 5)$ の部分でとなり合ってる要素を都合よく解釈してたのバカすぎて面白い。この制約でも上手い事やれば今の方針でいけるのかな～と思ってちょっと考えたけど、面倒なことになりそうだったので方針を変えた。宝の数が高々 $2 \\times 10 ^ 5$ 個なので主客転倒してそれぞれの宝についてその宝をゲットできるマスの数を数え上げることにした。これは下図のようになる。\n最初はこれを愚直に数えようと思ってたけど面倒なのでもうちょっと楽な方法を考えた。一旦長方形部分を全て足し、後から余分な部分(三角形か台形になる)を引けば楽そうだと思い、この方針で実装した。なんかWAがでてビックリした。確認したらオーバーフローしてたのでlong longを使い、やっとAC。\nG\r良い知らせがあるマスを通る回数を最大化すれば良い。列方向に走査してセグ木に行の情報をもつ。各行においてその行における良い知らせのマスを通る回数の最大値を求めておいて各列の良い知らせがあるマスについて適宜更新する。これ書いてAC。これが一番典型っぽくてやりやすい気がした。\nH\rのこり10分だったので急いで考えた。Cでの考察を利用して、Z-algorithmを改造すればOK!と思い全力で書いて提出したがダメだった。\n感想\rペナが多すぎて笑った。問題文と制約を雑にみすぎてる。コンテストの仕組みを大して理解してないけどペナは多分出さない方がいい。初めてyukicoderのコンテストに参加したけど結構面白かった。次はなるべくペナを出さないようにしたい。\nupsolve\rそのうちやります。\n"},{"id":2,"href":"/docs/1676803816/","title":"ABC290","section":"ABC","content":"\r結果\rUS配列で参加する二回目のコンテスト。まだタイピングがおぼつかなくて、=を入力したかったのに_を入力してしまったり、*の位置が分からなくなったりする。 久々の三桁順位で萎えた。\nコンテストのURL\n振り返り\rA\rやるだけ。指の体操\nB\rK-- \u0026gt; 0で判定すると楽な気がする。\nC\r最初は$A$をソートしたりuniqueしたりしようとしてたけど、set使った方が楽なのでそっちに変更して書いた。\nD\r予選仕様なだけあってちょっとむずい気がしたけどqual Aよりはマシな難易度してた気がする。qual AのDは解法思い浮かぶまで時間かかったけどこれはすぐ浮かんだので。問題文を理解するのにちょっと時間がかかったけど用は$D$ずつ飛び飛びで塗って、同じ所に戻ってきたらずれるだけか～とわかった。マス$0$を出発した後、次にマス$0$に到達する時を$x$回目だとすると、$x \\times D \\equiv 0 \\pmod N$ が成り立つ。よって $x \\times D = \\operatorname{lcm}(D, N)$ となり、変形すると $x = N / \\gcd(D, N)$ となる。よって答えは \\(\r((K - 1) / x \u0026#43; ((K - 1) \\% x) \\times D) \\% N\r\\) となる。\nE\r思ったより面倒だった。$A_i$と$A_j(i\u0026lt;j)$ が対応するような連続部分列は $\\min(i, N - j + 1)$ 個なのでこれを全力で数え上げるか\u0026hellip;という気分になる。$i \\leq N - j + 1$ の場合と$i \u0026gt; N - j + 1$ の場合に分けて考える。\n$i \\leq N - j + 1$ の時、「$A_{i+1}\\sim A_{N-i+1}$ に含まれる $A_{i}$ と等しくない要素の個数」が分かれば良さそう。これをするには外部に $$ cnt[i]=(現在考えている区間に含まれているiの個数)$$ という配列を用意する。初めに全体に対して初期化しておく。その上で$i$を昇順に見ていき、\n答えに $(N - 2 \\times i + 2 - cnt[A[i]]) \\times i$ を加算。 $cnt[A[i]]$ と $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 とすればよい。$i \u0026gt; N - j + 1$ の場合も同様にすればよいが、この場合では等号がついていないので、デクリメントのタイミングが少し違い、\n$cnt[A[i]]$から$1$を引く。 答えに $(N - 2 \\times i + 1 - cnt[A[N - i + 1]]) \\times i$ を加算。 $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 とすればよい。これを書いて提出してAC。\n( 解説)\nF\rむっずい。マルチケースのくせして「$N$の総和は$1000000$を超えない」みたいな制約が無いので、漸化式があるか$O(1)$があるんだろうなという気分になる。$O(1)$ならOEISとかwolfram alphaで解けちゃうから漸化式かな～と考えた。今思うと漸化式も全然OEISで出てくる気がする。OEIS使ったこと全然無いので分からない。\nまずどんな数列のとき対応する木が作れるのか考えると、とりあえず全ての和が$2N-2$で、各次数が$1$以上$N-1$以下であるなら大丈夫そう。あるvalidな正整数列 $X$ に対する $f(X)$ はどれくらいかを考える。これは少し時間がかかったが、次数が$1$の頂点を両端に置き、間に次数$2$以上の頂点を並べれば良さそう。つまり$(次数2以上の頂点の数)+1$が最長の直径になる。漸化式なら$N+1$個目の頂点を追加した時の変化を観察すればええやろ！といろいろやった。長さがどう伸びるとか、通り数を管理すれば良いんじゃないか？とかやったが、数列が後から重複したり、次数が$1$の頂点の個数で分けて管理したくなったりして無理そうだった。\n漸化式よくわからんから$O(1)$も考えることにした。これも苦戦したが、そもそも全部の頂点の次数は$1$以上なんだから最初に全部配ってみることにした。そうすると残る次数は$N-2$であり、これをどんな分配しても次数の最大値が$N-1$を超えることは無い。ここら辺になってようやく光明が見えた気がしてきた。後は $\\displaystyle\\sum_{i=0}^{N-2}\\binom{N-2+i-1}{i-1} \\times (i+1)$ を計算すれば良さそうだが、これではマルチテストケースに対応できない。よく考えると主客転倒が出来て、「最初 $f(X)$ は $1$ で自分の次数が2以上なら $+1$ される」みたいな言い換えができる。よってある頂点に注目して、とりあえずその頂点に次数 $1$ を配って、残りの$N-3$を$N$個に分ければよい。これは $\\displaystyle\\binom{2N-4}{N-1}$ 通りである。この式は「$f(X)$を$1$で初期化した時からの追加分」を考えているので、初期化分を足す必要があること、注目する頂点は$N$通りであることに注意すると答えは $\\displaystyle{\\binom{2N-3}{N-1}+\\binom{2N-4}{N-1}\\times N}$ となる。$N=5$くらいならすぐ計算できるので計算して合ってることを確認してから書き始めた。自前の組合せライブラリを使ったけど、$1000010$で初期化したせいで1ペナついた。バカすぎ。\nG\rこのとき残り30分くらいだったので急いで考えた。こんなん沢山切れるとこから切るだけじゃんと思い、頂点の数が$X$を超える最少の高さの$K$分木を考えるだけの実装をした。WAが出てめっちゃ焦った。考察はミスってないし、ハックケースも浮かばないから実装ミスだと判断して実装ミスを探してたらコンテストが終わった。\n感想\r7完したかった\u0026hellip;。 最初は「慣れないUS配列で参加したからな、JIS配列だったら7完だったわ」みたいな言い訳を考えてたんだけど、Gをupsolveするのにめっちゃ時間がかかったので、JIS配列で出てても6完だったな…という気持ちになった。Gみたいな貪欲しつつ全探索する問題、いつまでたっても出来るようにならない。多分高校生の頃からずっと苦手で慣れない。貪欲法なら貪欲だけして終わり！という気分になって貪欲っぽくないところも貪欲でええか！ｗをしてしまいがちになる。ちゃんと証明をするか、怪しいケースを考えるべきだと感じた。今回なら「深さが3とか4のときに本当に最初に潜っていいか分からんな\u0026hellip;提出してWA出してから考えればいいか～」と思ってて、実装してる内に忘れてた。バカすぎ。\nDは1000diffちょっと超えてる位で、qual AのDは青diffだったのでやっぱり簡単になってた。Eはちょっと面倒だったので青かなぁと思ってたら水diffだった。解説を見ると結構簡単な実装をしてたので、僕が回り道をしてしまった感がある。あとFで詰めきれなくて死にそうになったが、ちゃんと詰めきれたのは良かった。数え上げ系は解けるとすっきりするので好き。数式の変形で殴るのは無理そうだと思って考察いろいろしてACしたけど数式の変形でも行けるらしくてビックリ。wolfram alphaを使うと楽にできるってのもビックリした。OEISとかwolframあたり、使いこなせない。\n次は7完したい。\nupsolve\rG\r本番投げた奴のどこが間違ってるか分からなくて、twitterで助けを求めたらcarrot46さんが教えてくれた。感謝。\n1\n4 2 9\nに3を返しますが、正しくは2です（根+根の子+根の子の子による部分木(頂点数7)を残すのが最適）\n\u0026mdash; carrot46 (@carrot46_kyopro) February 19, 2023 これ見る限り、根を使う場合は親とのつながりを切る必要が無いので、それだけ試せば良さそう。けどそれだけでええんか？と不安になり、念のため全ての部分木を試してみたらACした。 ACコード\n本解説を見たら解説1が僕の方法と同じだった。解説2の次数和に注目する方法はなるほど～となった。\n"},{"id":3,"href":"/docs/1677421396/","title":"ABC291","section":"ABC","content":"\r結果\rTOEFLの対策とABCどっちやるか迷ってABCやった。\n苦しい結果になった。\nコンテストのURL\n振り返り\rA\rやる。'A' \u0026lt;= c \u0026amp;\u0026amp; c \u0026lt;= 'Z'の部分はなにかしらのかたちでテンプレにぶち込んでいいのかなと思いながら実装してた。けどテンプレがでかくなりすぎるのが個人的にあんまり好きじゃないので悩む。\n追記: isupperについて twitterでdrogskolさんにisupperなる関数がstdに既に存在していることを教えてもらった。\nhttps://t.co/Dx8Y6fJVY8\nisupper は std にあります\n\u0026mdash; drogskol (@cureskol) February 26, 2023 このほかtoupperなど様々な便利関数があるらしい( locale - cpprefjp C++日本語リファレンス)。どこかの解説放送でisdigit関数だけ見たことがあり、それだけ知ってた。テンプレを膨らませなくて良くなったので嬉しい。\nB\rソートして平均取る。こういうのかいてるときrepマクロを整備しといて良かったって気分になる。\nC\rめんどい。移動をシミュレーションしながら座標をsetに入れて最後にsetのサイズを見ればいい。LRUDをそれぞれ0123に対応させたり進行方向に変換させたりしてくれる何かを持っていた方がいいかもしれん、とちょっと思った。\nD\rDPした。添え字をA[(表裏)][(カードの番号)]にしたせいでネストの順番と添え字の順番が逆なってしまい、きもいな\u0026hellip;直そうかな\u0026hellip;と悩んでるうちに実装が終わった。\nE\rトポソして、それが一意か見ればいいだけ。トポソをするときにqueueを使っているのでqueueのサイズが常に $1$ であることを確認する方針が最初に浮かんだ。入力を書いてる内に、どうせならqueue使わないで現在の頂点を保存する変数を1つだけもてばいいか？と思い、そっちを書き始めたが、書いてるうちに場合分けがだるそうな気がしてきたので最初の方針に戻した。\nF\r\\[\r\\begin{aligned}\rpre[i] \u0026amp;= 都市1から都市iまで移動するのに必要な最少のテレポート回数\\\\\rpos[i] \u0026amp;= 都市iから都市Nまで移動するのに必要な最少のテレポート回数\r\\end{aligned}\r\\] を求める。$pre[i]$ は配るDPで、$pos[i]$ は貰うDPで書けばいい。後は $i \\rightarrow j$ のワープが存在するなら各 $k (i\u0026lt; k \u0026lt; j)$ に対して $ans[k] \\leftarrow \\min(ans[k], pre[i] + pos[j] + 1)$ と更新するようにすれば答えが求まる。これ書いて提出したらWAがでて謎すぎた。しばらく眺めてみると $pre, pos$ をint型でとっていた上1 \u0026lt;\u0026lt; 30で初期化してたせいで、どちらも1 \u0026lt;\u0026lt; 30の時にオーバーフローしてた。intからlong longに直したらACした。\nこの時点でExがGよりも解かれててビックリした。とりあえずいつも通りG→Exの順番でやろうとしたら間違えてExから解いてた。\nG\rわからん。ビットごとに分けて考える。今考えてるビットの列を $a$, $b$ として、$a$ を $0, 1, 2, 3, \u0026hellip;$ とシフトさせたときのORの和をすぐに計算出来れば良さそう。$1$ の個数を考えるよりも$0$の個数を考えれば楽で、シフトした後の数列 $a^{\\prime}$と数列 $b$ でどちらも $0$になっている要素の数が分かればよい。つまるところ、数列 $a, b$ それぞれの $0$ となっている要素のインデックスの差分を列挙、カウントすればいよい。どっかで見たことあるけど分からなかった。セグ木とか平方分割とか考えたけど全然できなかった。そもそも全シフトを試すのが違うのか？とか考えたけど、これ以外の方針も浮かばず、うんうん唸ってたらコンテストが終わってしまった。\nEx\rGと勘違いして解いてた。重心分解して重心をくっつけていくという解法が最初に浮かんだが「ABC-Gで重心分解は、やばいだろ」と感じ想定解は多分違うんだろうな～と思ってしばらく別解を考えてた。適当に根をきめてDFSで潜りながら上手い事ずらしていく方法などを考えたが、実装が重そうだし細かい部分がよくわからんから重心分解を書くことにした。一応自作ライブラリ見たけどやっぱり重心分解はなかったのでネットから強奪してくるか自分で書くか～という気分になった。重心分解書いてる間にEx考えようと思って別タブでExを開いたら同じ問題が出てきてビックリした。試しにG開いたら知らない問題が載ってた。Exなら重心分解でても納得だな、と思いながら人のライブラリ探しに行った。けどどうやって使うか理解するのが億劫になって自分で書いた。一発でACできたのは結構うれしい。\n感想\rここ最近オーバーフローでペナを出し過ぎてる気がする。あと差分列挙を完全に忘れてたのがマジでよくない。ABC196-Fをupsolveしたときに感動したんだけど、そのまま忘れてた。コンテスト終わってからしばらくは「なんで畳み込みを考えなかったのかのか自分でも謎だな\u0026hellip;」と思ってたが、そもそも僕が畳み込みを使えるか考えるのは$998244353$の時だけかもしれないと気付いた。今後は$998244353$関係なく畳み込みを考えられるようにしたい。 $O(N\\log N)$ での重心分解の実装が思ってたよりも軽かったのと、それをすぐに書けたのは良かった。\nupsolve\rG\rTLで畳み込みという情報だけ手に入れてupsolveした。 ABC196-Fとほぼ同じ。言われてみればいかにも畳み込みっぽい形なので、典型とか関係なしに畳み込みの気分になるべきだったかもしれんと思った。畳み込みは次数の和が一定となる組合せの積の和をもとめるので、差分について求めるためにはどちらかの数列を反転してやればよい。あとは次数について $\\pmod N$ を考えるように注意しながら数え上げてAC。実装自体は軽かった。\n"},{"id":4,"href":"/docs/1676882511/","title":"E","section":"ABC290","content":" 問題のURL\n問題概要\r長さ$N$の数列$A$が与えられます。この数列の全ての連続部分文字列において、数列を回文にするために変更する必要のがある要素の個数の最小値を求め、それらの和を出力してください。\n解法\rどのような場合が答えに寄与するか考える。これは $A_i$と$A_j(i\u0026lt;j)$ が違い、かつそれらを対応付ける連続部分列が存在する場合である。$i, j$を固定した時、これらを対応付けるような連続部分列は $\\min(i, N - j + 1)$ 個である。よって $A_i\\neq A_j$ となるペア $(i, j)$ についてこれの和を求めればよい。 $i \\leq N - j + 1$ の場合と$i \u0026gt; N - j + 1$ の場合に分けて考える。\n$i \\leq N - j + 1$ の時、$i$を固定して$j$を動かしてるように考えれば良く、「$A_{i+1}\\sim A_{N-i+1}$ に含まれる $A_{i}$ と等しくない要素の個数」が分かれば良い。$A_i$を区間に含めても問題ないので、「$A_{i}\\sim A_{N-i+1}$ に含まれる $A_{i}$ と等しくない要素の個数」を考える。これをするには外部に $$ cnt[i]=(現在考えている区間に含まれているiの個数)$$ という配列を用意する。なお、初めは区間を全体として初期化しておく。その上で$i$を昇順に見ていき、\n答えに $(N - 2 \\times i + 2 - cnt[A[i]]) \\times i$ を加算。 $cnt[A[i]]$ と $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 とすればよい。要するに、区間$[i, N-i+1]$を考えた後、$i$番目と$N-i+1$番目の情報を削ることで区間$[i+1,N-i]$の情報に更新する、ということを繰り返している。\n$i \u0026gt; N - j + 1$ は$j$を固定して$i$を動かしているように考えればよい。ここでは$j=N-i+1$としている。この場合も先ほど大体同じだが等号がついていないので、デクリメントのタイミングが先ほど少し違い、\n$cnt[A[i]]$から$1$を引く。 答えに $(N - 2 \\times i + 1 - cnt[A[N - i + 1]]) \\times i$ を加算。 $cnt[A[N - i + 1]]$ から$1$引く。 $i \u0026lt; \\lfloor N / 2 \\rfloor$ なら1. に戻る。そうでないなら終了。 となる。一番最初にデクリメントすることで考えている区間が$[i+1, N-i+1]$になる。\nコード\r#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long int N, A[200010], cnt[200010]; int main() { int N; cin \u0026gt;\u0026gt; N; for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; A[i]; cnt[A[i]]++; } ll ans = 0; for (int i = 1; i \u0026lt;= N / 2; i++) { ans += 1ll * (N - 2 * i + 2 - cnt[A[i]]) * i; cnt[A[i]]--, cnt[A[N - i + 1]]--; } for (int i = 1; i \u0026lt;= N; i++) cnt[i] = 0; for (int i = 1; i \u0026lt;= N; i++) cnt[A[i]]++; for (int i = 1; i \u0026lt;= N / 2; i++) { cnt[A[i]]--; ans += 1ll * (N - 2 * i + 1 - cnt[A[N - i + 1]]) * i; cnt[A[N - i + 1]]--; } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } Submission\n備考\rABC290 参加記\n"},{"id":5,"href":"/docs/1676803850/","title":"E","section":"ECR143","content":" 問題のURL\n問題概要\r解法\rコード\rSubmission\n備考\r"},{"id":6,"href":"/docs/1676803810/","title":"ECR143","section":"Div. 2, ECR","content":"\r結果\r丁度キーボードが届いた日のコンテストだったので、US配列に慣れる良い機会だと思って参加した。\n思ったより出来たので満足。 EFあたりが「これマルチケースなんですか…？」って感じの問題で実装が結構苦しかった。\nコンテストのURL\n振り返り\rA\r図があるな～と思いながら読んでた。一方の文字列の上から取った連続部分列をリバースして他方の文字列にくっつける操作しか出来ないことを確認して、sとtをリバースした物をくっつけてRR, BBの個数を数えた。もしも1つだけならそこで区切ればよいが、2つあったらどう分けても同じ色が隣接する部分が出てくるのでダメ。\n思ったよりスムーズに考察出来た気がしたがACまで6分強かかっててびっくりした。\nB\r制約小さいからごり押し探索でもやるのかな？と思って考察してみたけど、これ $l_i=k$ を満たすような $i$ と $r_j=k$ を満たすような $j$ があればよくない？となり、提出してAC。あんまり制約小さいのが生きなかったので不安だったが、ひっかけみたいなもんだと思うことにした。\nC\r図の意味がよくわからなかったのでスルーした。おもったより難しくて焦った。前から見て行って「今どんな量の飲み物が残っているか」がうまく管理できればいいよねって感じがしたので、その方針を考えてみる。$i$ 番目の人について考えているとき、残っている飲み物それぞれから $b_i$ を引く必要があり、この処理で $0$ を下回る飲み物には特別な処理が必要になりそう。全体から同じ数引くのは無理なので下駄を履かせてpriority_queueで常勝！って感じになる。\n考察が終わってみると大典型だった。\nD\r今回の問題の中で一番素朴だと思った。うまく配置すれば各トライアングル内で2本の辺を使うことができる。このとき、赤2つ青1つのトライアングルが $n/6$ 個、赤1つ青2つのトライアングルが $n/6$ 個となるのでトライアングルごとの塗り分け方は $\\displaystyle \\binom{n/3}{n/6}$ 通りとなる。トライアングル内の色の塗り方は\nすべて同じ重さ → 3通り 重さが2種類で重い方が2つ → 1通り 重さが2種類で軽い方が2つ → 2通り 重さが3種類 → 1通り となるので、あとは全部掛け合わせて終わり。\nD解き終わって問題一覧に戻るとEFGのAC人数がG \u0026gt; F \u0026gt; Eの順番になってて、どれから解けばいいんだ…？となった。とりあえずE開いたら問題文が長かったのでFG解いてる人は問題文長いから後回しにしたんだろうと考え、順番通りEを解くことにした。\nE\r読むのだるかったが読んだ。爆発に必要なマナが増えるほどbasic spellの詠唱回数が減るから三分探索でもすんのかな？って思った。三分探索するとしたら結局爆破する位置によってbasic spellを何回唱えるか数える必要があるからこっち先に考えるか～という気分になる。\nある位置で爆破を起こした時、左を全消しするのに必要なマナと右を全消しするのに必要なマナが分かればよさそう。対称性があるので左を全消しにする場合だけ考える。昇順で見ていって $i$ 番目を考えているとき、「$i-1$番目を爆破したときに左を全消しするのに必要なコスト」からうまいこと計算出来ればいいなぁという気分になる。$h_{i-1} \u0026lt; h_{i}$ のときはそのまま引き継げばよいが、そうでない時は少し面倒。$h_{i-1}$ を $h_{i} - 1$ まで削る必要がある。さらに、これによって $h_{i-2}$ が爆破できるかも変わってきてしまう。どうしましょう…ってなって途方に暮れる。よく考えるとヘルスの差がずっと1の区間は先頭が削られたら後続も同じ分だけ減らさないといけない。よってこの処理はまとめられる。つまり連続してる区間を保存しておいて順番に見ていけば良く、これをやるにはstackが都合がいい。計算量を考えると、$i$ 番目を見ているとき、区間 $[i, i]$が追加されたと考える。これを元にstackの先頭を見て、削る必要があればpopして削り現在の区間に加える。削らなくてよいなら終了。と処理すれば追加された区間たちは高々1回popするだけで、popしない場合は各処理で一回ずつなので償却で $O(N)$ となる。\n実装するときは左を全消しするのに必要なコストを計算する関数を用意するとリバースしたやつ突っ込んで右も計算できるので楽。 こんな感じ コンテスト本番はこんなの書いてたけど、ちょくちょく無駄があります。\nvector\u0026lt;ll\u0026gt; calc(vector\u0026lt;ll\u0026gt; v) { int n = v.size(); stack\u0026lt;pll\u0026gt; st; st.push({v[0], v[0]}); vector\u0026lt;ll\u0026gt; ret(n, 0); rep(i, 1, n) { ret[i] = ret[i - 1]; ll lw = v[i], hi = v[i]; while (!st.empty()) { auto [l, h] = st.top(); if (h \u0026lt; lw) break; st.pop(); ret[i] += (l + h) * (h - l + 1) / 2; ll nlw = max(0ll, lw - h + l - 1); if (lw) ret[i] -= (lw - 1 + nlw) * (lw - nlw) / 2; lw = nlw; } st.push({lw, hi}); } return ret; } あとは三分探索するだけや！と思い、三分探索を書き始めそうになったが、まずbasic spellに狭義の単調性があるのか分からないし、そもそも三分探索しなくてもそれぞれの地点で爆破起こした時の最小コスト分かるじゃんとなった。たまたま方針が死ななかっただけなので、運が良かった。いざ提出していみるとWAが出てしまい、結構メンタルにきた。バグりそうな部分はわりとちゃんと確認してから提出したつもりだったのでどこでWAが起きたか見当がつかなかった。丁寧に確認したのは部分和とるとこなので、そこ以外を確認するとlong longであってほしい所が intになっていた。そこを直したらACになった。これでペナついたのしょうもなさ過ぎて悲しくなった。\nF\r最初チップが移動したら移動前の頂点は白色に戻ると思い込んでたけど、そんなことは無いらしい。ようはある頂点を端点とするパスを出来るだけ並列して沢山伸ばしたいってことっぽい。シミュレーションしてくのは流石に無理でしょって感じがした(衝突した時に伸ばしなおすんだろうけどどこに伸ばすかの宛てが無いのでむりそう)ので、どうにかしてパスの長さを決め打つことにした。最大と書いてあるので二分探索やね、となり二分探索してそれぞれのパスの長さを固定した。そうすると後は木DPをするだけで良い。\n子からパスは伸びてきているか 子孫のうち、使えるパスの最大長はどれくらいか を考慮して衝突した場合などをうまく処理してAC。実装に結構手こずった。というか考察があまい状態で実装を始めたので場合分けやDFSでの戻り値をどうするかなどで時間を食ってしまった。\nG\rこの時点で残り22分だったので、「さすがにACまでは無理だな…」と思いつつとりあえず問題文を読んだ。これ全消し出来ない場合はどうするの？と思ったが、\nAdditional constraint on the input: there always exists at least one valid sequence of removals.\nと書いてあったので考えなくて良いらしい。この条件から現在除外可能な頂点は隣り合うことがなくて、貪欲に取っていくことで除去する頂点の順番を表すDAGが出来るので、あとは各頂点に関して「自分からは到達できないし、相手からも到達できない」ような頂点を数え上げれば良さそうだと思った。これ、頭が回ってなくてDFSで出来ると思ってたけど全然できない。本番はDFS全力で書いていたら時間切れになってしまった。\n今のところbitset使うくらいしか思いつかない。\n感想\r全体的におおまかな解法は結構すぐ浮かんだが、細部を考えずに突き進んだせいで実装でわちゃわちゃしてしまった。これは細部に嘘があった場合死ぬのであまり良くない。次回はしっかり詰めてから実装したい。JIS配列では書きやすかった記法がUS配列では指の動きが多くて大変ということが結構あったので、キーボードを変えるとコードの書き方も変わるようになるのかなと思った。あとEFは関数を多用したくて、そうなるとグローバル変数として全部置くのが楽なんだけどマルチケースなので初期化が必要になり、めんどいな…という気分になった。ラムダ式に感謝。\n最近のDiv2、毎回全完一歩手前で終わっちゃう。一回くらい全完してみたい。\nupsolve\rG\rDAGになるのはよくて、後はbitsetで高速化するだけだけどこのサイズのbitsetは間に合わない気がするな\u0026hellip;と思って諦めて解説を見た。bitsetっぽいことをするが、そのままbitsetを使うとMLEするらしい。なのでlong longを使い、 $64$ 個ずつ判定することでメモリを削減するテクが載っていた。単純なテクだけど、それでちゃんと間に合うのですごい。流石に単純に64倍速とはいかなくてforが増えるしまにあわないんじゃない？って思ってた。自作bitsetを持ってる人はそのまま殴れたりするのかかな～とか考えてた。\n__int128_tつかってやれば更に速くなるかと思いやってみた。__int128_t用のpopcountが見つからなかったので↓みたいな関数を定義してカウントした。\nint my_popcount(int128 x) { return __builtin_popcountll(x \u0026amp; ULLONG_MAX) + __builtin_popcountll((x \u0026gt;\u0026gt; 64) \u0026amp; ULLONG_MAX); } 結果、2433msから3010msとなり、遅くなってしまった。無念。あらたに足し算をする必要が出てきたのと、そもそも__int128_tの演算が遅いってのがありそう。ここら辺の詳しい解析の仕方をそのうち学びたい。\n"},{"id":7,"href":"/docs/1677606331/","title":"ECR144","section":"Div. 2, ECR","content":"\r結果\rあったので出た。\nまあまあの出来。\nコンテストのURL\n振り返り\rA\r事前に適当な長さだけFB-stringを作って与えられた文字列がこれの部分列か見ればいいだけ。最初$30$までのFB-stringを作って提出したら長さが足りなくてペナが出た。\nB\r編集距離みたいにやったあと復元かな、と思ってDPするところまで書いて、嘘であることに気づいた。最大共通部分列を取ってくるのが最適とは限らない。よく考えたら先頭が一致してたらそれ以降を*、末尾が一致してたらそれ以前を*、どちらでもないなら共通する長さ $2$ の連続部分文字列があるならそれの前後に*、そうでないなら作れない。\nC\rなにこれ？集合内で自分の次に大きい要素はそいつで割り切れて、逆にそうなっているならbeautifulな集合になっている。よって $l\\times 2^k \\leq r$ を満たす最大の $k$ を取ってくるとこれがサイズの方の答えになる。またこれが集合の最大の要素を最小の要素で割った時の商になっている。あとは $3 \\times 2^{k-1}$ の場合も考えればよい。$2$ の代わりに $4, 5, \u0026hellip; $ を使うことは絶対にできないのでこれで十分。例えば $2$ の代わりに $4$ をかけれるならサイズを $1$ 増やせるはず。これ絶対 $998244353$ こえなくね？って思ってしばらく確認してたけど、これで合ってそう。一応modint使って提出したらWAがでた。やっぱり考察ミスか？と思って考察し直したけどヤバい所は無さそう。実装を見直したら最大が最少の $3 \\times 2^{k-1}$ 倍となる場合の計算において場合によっては答えが負になるような実装をしていた。これを直してAC。\nD\r大変だった。$i$ 番目を右端として、$i-k+1\\sim i$ が左端となる場合を愚直に探索する。 左端が $i-k$ 以下となる場合はセグ木で対応すればよい。セグ木には $\\displaystyle\\sum_{k=0}^{i}a[i]-x\\times i$ を入れておけばよい。$x$ が負の場合もこれで良いと思ってサンプル入れたら最後のケース ( $x$ が負の場合) だけ落ちた。もう一回考えたら確かに全然ダメだった。しょうが無いので負の場合も場合分けして実装する。 $x$ が負の場合はとりあえず 右端を $i$ として、もしも $n-i \\geq k$ なら 区間の全てに $|x|$ を加算することができる。よって左端を好きに決めてよい。この計算は先ほどと同じようにできる。$n-i\u0026lt;k$ となるような $i$ は　$k-1$ 個で $k\\leq 20$ なので、このような $i$ に関しては左端を全探索する。区間内で $+x$ されるような要素の数が最少になるようにすればよい。結構バグを埋め込んでしまったが、幸い提出前に全て修正でき、一発でAC出来た。\nE\r二分探索で長さ決め打って木DPって方針で実装してた。部分木に根がある場合とない場合で場合分けしながら木DPするような実装して5分前くらいに提出したけどWA。細かい部分での場合分けが多すぎた。何回か修正して提出して\u0026hellip;を繰り返していたらコンテストが終わった。\n感想\rBでDP復元を書ききる前嘘に気付いたのは良かった。できれば書き始める前に嘘と気付きたい。Cみたいな問題、混乱するので $998244353$ とか書かないでほしい。答えが大きくなる可能性があるので～のとこ、嘘じゃないか？って思ったけどその値が大きいか大きくないかは悪魔でも主観なのでOK！みたいな理屈なのかもしれない。Dはめんどくさい実装をしてしまったので大分大変だった。今考えると累積minが欲しいのでセグ木いらない気がしてきた。upsolveのときに確認する。EはTLで全方位木DPと言われているのをみて、そっか～ってなった。全方位木なぜか考えてなかった。自分でも謎。Eを書いてる時「これ絶対めんどくさいしバグらせるだろ」って思いながら実装してたしもうちょっと考察するべきだった。FのAC数が0人のままおわったの怖すぎる。次のECRは2桁順位とりたい。\nupsolve\rE\r全方位木DPという情報を見た状態で取り組んだ。最初は二分探索+全方位木DPだと思ったが、よくよく考えると二分探索はいらない。根を決めたら深さ優先探索をしてそれぞれの部分木で\n子から伸びているパスのうち、一番小さいやつを伸ばす 伸ばしたパス以外はそこで打ち切られたものとしてそれらの最小値を考える といった貪欲法で出来る。根を決めた場合の貪欲法が分かったので、あとはこれを全方位木DPでそれぞれを根とした場合を再現するだけ。思ったよりも実装が面倒になってしまった。全方位木DP、今から伝播させたい子ノードの情報を一旦差し引いて、残りの情報から伝播させる情報を計算して、データを戻す、ってのを繰り返す部分で毎回バグらせている気がする。\n今回はmultiset内の要素のうち二番目に小さい物、という情報が欲しかったのだが、これ毎回以下のように書いてて\nmultiset\u0026lt;int\u0026gt; st; // いろいろ挿入 auto it = st.begin(); it++; // *itで取得 値の取得まで含めると三行かかっていたのでめんどくさかった。これの楽な書き方をtwitterできいたらstoqさんとdrogskolさんから*next(st.begin())を使うと良い、と教えていただいた。\n*next(st.begin())だと1行で書けていいかもしれません\n\u0026mdash; stoq (@stoq_) March 1, 2023 *next(st.begin()) とかでしょうか\n第二引数を使えば k 番目にも O(k) で対応出来ます\n\u0026mdash; drogskol (@cureskol) March 1, 2023 まさに求めていたものだったのでとてもありがたかった。ありがとうございます。\n"},{"id":8,"href":"/docs/books/patahene/","title":"パタヘネ 第6版","section":"参考書","content":"\r概要\rここにはにはコンピュータの構成と設計 第6版の僕の解答を載せます。\n"},{"id":9,"href":"/docs/contests/","title":"参加記","section":"Docs","content":"主にAtCoderやCodeforcesの参加記を書きます。基本的に本番の記録に使いますが、upsolve時の感想やシステスの感想なども書くかもしれません。また、面白いと思った問題は参加記とは別に解説を書いて見たいと思っています。\n"},{"id":10,"href":"/docs/editorial/","title":"解説","section":"Docs","content":"\r解説\rここでは面白いと思った問題の解説や、解説が難解だと感じた問題の自分なりの解釈書きます。\n"},{"id":11,"href":"/docs/books/","title":"参考書","section":"Docs","content":"\r参考書\rここには解説が載っていない参考書の自分なりの解答を書きます。ただし、分からない問題は欄だけ作成し、放置しておきます。間違いや、空白となっている問題の答えが分かった場合はtwitterのDMやGitHubのissueなどで教えてくれるととてもありがたいです。\n連絡先\n"}]