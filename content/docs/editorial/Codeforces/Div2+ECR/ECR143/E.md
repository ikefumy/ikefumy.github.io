---
linktitle: "E"
title: "ECR143-E 解説"
weight: 1
# bookFlatSection: false
# bookToc: true
# bookHidden: false
# bookCollapseSection: false
# bookComments: false
# bookSearchExclude: false
url: "docs/1676803850"
tags:
- ECR143
- ECR
cahegories:
- 解説
---

[問題のURL](https://codeforces.com/contest/1795/problem/E)

## 問題概要

モンスターが $n$ 匹並んでおり、$i$ 番目のモンスターの体力は $h_i$ です。これに対し以下の順番で操作を行います。

1. コスト $1$ かけて通常攻撃を行う。
2. 必要ならば1. に戻る。
3. 爆発を行う。

通常攻撃とは以下のような操作です。

1. $1\leq i \leq n$ を満たす整数 $i$ を選び、$h_i$ の体力を$1$減らす。

"爆発"とは以下のような操作です。

1. $1\leq i \leq n$ とある値$x$を決める。
2. コスト $x$ をかけて $h_i$ の値を $x$ 減らす。
3. $h_i$が$0$より大きいのなら終了
4. もし $h_{i-1}<h_{i}$ ならば $h_{i-1}=0, i \leftarrow i-1$として4. に戻る。
5. もし $h_{i+1}<h_{i}$ ならば $h_{i+1}=0, i \leftarrow i+1$として5. に戻る。

すべてのモンスターの体力を $0$ にするために必要な最少コストを求めてください。

## 解法

爆発によって綺麗に消すために通常攻撃で数列を整えるイメージです。また、爆発を起こす地点のモンスターに通常攻撃をする必要はありません。なぜなら通常攻撃削った分を爆発のコストに加えることでより高威力の爆発を起こせるからです。すべての地点において「爆発をこの地点で起こした時に必要なコストの最小値」を求め、それらの最小値を求めれば全体の最小値を求めることができます。よって「ある地点 $i$ で爆発を起こすと決めたときに必要なコストの最小値」を求める事にします。簡単のため、左側への伝播だけを考えます。

愚直にやれば「出来るだけ爆発が伝播するように都度通常攻撃で体力を削り走査する(削った分は爆発を起こす前に削っておいたと考える)」という計算になりますが、これでは各地点で最悪の場合 $O(N)$ かかってしまいTLEしてしまいます。そこで $i$ 番目の計算をするために $i-1$ 番目での計算を利用することを考えます。ひとまず $i-1$ 番目の伝播は計算されており、なるべく爆発が伝播するように $1 \sim i-2$ 番目の体力が削れらている物とします。$i$ 番目の爆発が $i-1$ 番目のモンスターに伝播するためには $h_{i-1}< h_{i}$ が必要です。これを満たす場合はそのまま $h_{i-1}$ の結果を引き継げばよいです。そうでない場合、$h_{i-1}$ を通常攻撃で削る必要があります。$h_{i-1}$ を削った影響で $h_{i-2}$ を削る必要が出てくるかもしれません。そして $h_{i-2}$ を削った影響で $h_{i-3}$ も...みたいなことになります。

こういう削るべきところまで順次戻るという操作はstackを用いると実装しやすいです。ただそのまま実装するとTLEします(多分)。なのでまとめられる処理はまとめます。今回なら差が1の区間は一気に削れるため、stackに区間を入れるようにすることで、このような区間を一気に削れるようにします。例えば $3, 4, 5, 6$ という体力の列があった場合、これを区間 $[3, 6]$ と捉える事にします。こうすると先頭の $6$ が $5$ になった時、区間を $[2, 5]$ とするだけで済みます。先頭が $6$ から $5$ になったということはこの区間の手前に区間 $[6, x]$ があったということです。なので削った後は区間をまとめることができます。つまりこれら2つの区間を $[2, x]$ という1つの区間にまとめることができます。 $i$ 番目のモンスターを見るたびに区間 $[h_i, h_i]$ が加えられたと考えるようにすると、加えられる区間の個数は $O(N)$ 個、区間をstackからpopして前の区間に結合する回数も $O(N)$ なので償却計算量 $O(1)$ となり間に合います。

なお区間を減少させる際に途中で $0$ になる場合に注意して実装する必要があります。例えば区間 $[3, 6]$ の先頭が $1$ となり、区間が $[0, 1]$ となる場合です。また、実装する際には左側を全て $0$ にするのに必要なコストを計算する関数を用意して、リバースした数列を渡すことで右側も同じ関数で計算できるようにすると実装量が減るため楽です。

## コード

```cpp

```
[Submission]()
## 備考
 [ECR143 参加記]({{% ref "/docs/contests/Codeforces/Div2+ECR/ECR143/" %}})